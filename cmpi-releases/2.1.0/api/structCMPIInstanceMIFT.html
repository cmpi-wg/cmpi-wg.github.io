<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>CMPI Standard: CMPIInstanceMIFT Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_cmpi.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CMPI Standard
   &#160;<span id="projectnumber">2.1</span>
   </div>
   <div id="projectbrief">Online documentation generated from the CMPI Standard headers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">CMPIInstanceMIFT Struct Reference<div class="ingroups"><a class="el" href="group__instance-mi.html">Instance MI Functions (Subclause 6.3)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Function table of <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> object.  
 <a href="structCMPIInstanceMIFT.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cmpift_8h_source.html">cmpift.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a17245f1cae07d445b87b7440a962b38a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type-version.html#ga4c18cda6bf4c6fea28f0af97248a40ba">CMPIVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a17245f1cae07d445b87b7440a962b38a">ftVersion</a></td></tr>
<tr class="memdesc:a17245f1cae07d445b87b7440a962b38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CMPI version supported by the MI for this function table.  <a href="#a17245f1cae07d445b87b7440a962b38a">More...</a><br/></td></tr>
<tr class="separator:a17245f1cae07d445b87b7440a962b38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d66188db7e6777dc29f5171824ab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a953d66188db7e6777dc29f5171824ab1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a953d66188db7e6777dc29f5171824ab1">miVersion</a></td></tr>
<tr class="memdesc:a953d66188db7e6777dc29f5171824ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informal MI-specific version number for this MI. <br/></td></tr>
<tr class="separator:a953d66188db7e6777dc29f5171824ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc435b3430cfdcb2d5b8ceb0aa7628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bbc435b3430cfdcb2d5b8ceb0aa7628"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a1bbc435b3430cfdcb2d5b8ceb0aa7628">miName</a></td></tr>
<tr class="memdesc:a1bbc435b3430cfdcb2d5b8ceb0aa7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informal MI-specific name for this MI. <br/></td></tr>
<tr class="separator:a1bbc435b3430cfdcb2d5b8ceb0aa7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c33f93e25c564f25f84d96c4f8f7354"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a5c33f93e25c564f25f84d96c4f8f7354">cleanup</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, <a class="el" href="group__types-cim-types.html#ga8497f332926ff39d6bb5e1cb96cbb89d">CMPIBoolean</a> terminating)</td></tr>
<tr class="memdesc:a5c33f93e25c564f25f84d96c4f8f7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cleanup for an Instance MI.  <a href="#a5c33f93e25c564f25f84d96c4f8f7354">More...</a><br/></td></tr>
<tr class="separator:a5c33f93e25c564f25f84d96c4f8f7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5520a37f447e153dddba1c4c12d32a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#aac5520a37f447e153dddba1c4c12d32a">enumerateInstanceNames</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath)</td></tr>
<tr class="memdesc:aac5520a37f447e153dddba1c4c12d32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate instance paths of instances of a given class serviced by this MI.  <a href="#aac5520a37f447e153dddba1c4c12d32a">More...</a><br/></td></tr>
<tr class="separator:aac5520a37f447e153dddba1c4c12d32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f65e050dd7a5a8b8a9d1446fbfcdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a32f65e050dd7a5a8b8a9d1446fbfcdcd">enumerateInstances</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const char **properties)</td></tr>
<tr class="memdesc:a32f65e050dd7a5a8b8a9d1446fbfcdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the instances of a given class that are serviced by this MI.  <a href="#a32f65e050dd7a5a8b8a9d1446fbfcdcd">More...</a><br/></td></tr>
<tr class="separator:a32f65e050dd7a5a8b8a9d1446fbfcdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd99f019353734c2ef1eec95d4f605ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#acd99f019353734c2ef1eec95d4f605ba">getInstance</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *instPath, const char **properties)</td></tr>
<tr class="memdesc:acd99f019353734c2ef1eec95d4f605ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an existing instance.  <a href="#acd99f019353734c2ef1eec95d4f605ba">More...</a><br/></td></tr>
<tr class="separator:acd99f019353734c2ef1eec95d4f605ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101d136d2ccc12fd098bf3499b2c96ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a101d136d2ccc12fd098bf3499b2c96ca">createInstance</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const <a class="el" href="structCMPIInstance.html">CMPIInstance</a> *inst)</td></tr>
<tr class="memdesc:a101d136d2ccc12fd098bf3499b2c96ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of a given class.  <a href="#a101d136d2ccc12fd098bf3499b2c96ca">More...</a><br/></td></tr>
<tr class="separator:a101d136d2ccc12fd098bf3499b2c96ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39091dc87dd2f06879afbb8ecc7da62b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a39091dc87dd2f06879afbb8ecc7da62b">modifyInstance</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *instPath, const <a class="el" href="structCMPIInstance.html">CMPIInstance</a> *modInst, const char **properties)</td></tr>
<tr class="memdesc:a39091dc87dd2f06879afbb8ecc7da62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify property values of an existing instance.  <a href="#a39091dc87dd2f06879afbb8ecc7da62b">More...</a><br/></td></tr>
<tr class="separator:a39091dc87dd2f06879afbb8ecc7da62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad186fef3dd991a1e9b2551102b0ac1c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#ad186fef3dd991a1e9b2551102b0ac1c3">deleteInstance</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *op)</td></tr>
<tr class="memdesc:ad186fef3dd991a1e9b2551102b0ac1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing instance.  <a href="#ad186fef3dd991a1e9b2551102b0ac1c3">More...</a><br/></td></tr>
<tr class="separator:ad186fef3dd991a1e9b2551102b0ac1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa391cf28e2369eeea1776b55201a2da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#aa391cf28e2369eeea1776b55201a2da2">execQuery</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const char *query, const char *lang)</td></tr>
<tr class="memdesc:aa391cf28e2369eeea1776b55201a2da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a query on a given class and return the query result.  <a href="#aa391cf28e2369eeea1776b55201a2da2">More...</a><br/></td></tr>
<tr class="separator:aa391cf28e2369eeea1776b55201a2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3407e6bd5c82e70bbd02a00260b8d69a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCMPIInstanceMIFT.html#a3407e6bd5c82e70bbd02a00260b8d69a">enumerateInstancesFiltered</a> )(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const char **properties, const char *filterQuerylanguage, const char *filterQuery, <a class="el" href="structCMPIStatus.html">CMPIStatus</a> *rc)</td></tr>
<tr class="memdesc:a3407e6bd5c82e70bbd02a00260b8d69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the instances of a given class that are serviced by this MI, returning only those that match a given query filter.  <a href="#a3407e6bd5c82e70bbd02a00260b8d69a">More...</a><br/></td></tr>
<tr class="separator:a3407e6bd5c82e70bbd02a00260b8d69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Function table of <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> object. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a17245f1cae07d445b87b7440a962b38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type-version.html#ga4c18cda6bf4c6fea28f0af97248a40ba">CMPIVersion</a> CMPIInstanceMIFT::ftVersion</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CMPI version supported by the MI for this function table. </p>
<p>Any later CMPI versions are implicitly also supported.</p>
<p>See <a class="el" href="group__sym-version-nnn.html">CMPIVersion&lt;NNN&gt;</a> for valid CMPI version numbers. </p>

</div>
</div>
<a class="anchor" id="a5c33f93e25c564f25f84d96c4f8f7354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::cleanup)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, <a class="el" href="group__types-cim-types.html#ga8497f332926ff39d6bb5e1cb96cbb89d">CMPIBoolean</a> terminating)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform cleanup for an Instance MI. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#a5c33f93e25c564f25f84d96c4f8f7354" title="Perform cleanup for an Instance MI. ">CMPIInstanceMIFT.cleanup()</a> shall perform any necessary cleanup for the Instance MI identified by <code>mi</code>, unless the MI postpones the cleanup.</p>
<p>While this function executes, the MB will not call any other MI functions for this MI. This function will be called once for a specific MI (unless the MI postpones the cleanup), even if that MI services more than one namespace. After this function returns, the MB may unload the load library this MI is part of, unless the MI postpones the cleanup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. The context data entries are MB implementation-specific. </td></tr>
    <tr><td class="paramname">terminating</td><td><p class="starttd">Indicates whether the MB is in the process of shutting down and thus cannot tolerate postponing of the cleanup, as follows:</p>
<p>When True, the MB is in the process of shutting down. The MI shall perform any necessary cleanup and shall not postpone the cleanup. After this function returns (successful or in error), the MB will consider this MI to be uninitialized and will not call further MI functions for this MI.</p>
<p>When False, the MI can choose to perform or postpone the cleanup, by performing one of these actions:</p>
<ul>
<li>The MI performs any necessary cleanup and does not request postponing the cleanup. After this function returns (successful or in error), the MB will consider this MI to be uninitialized and will not call further MI functions for this MI. </li>
<li>The MI does not perform any cleanup and temporarily postpones the cleanup, by returning <code>CMPI_RC_DO_NOT_UNLOAD</code>. This will cause the MB to consider this MI still to be initialized, and the MB may call further MI functions of this MI. The MB may call this function again after some MB implementation-specific time. </li>
<li>The MI does not perform any cleanup and permanently postpones the cleanup, by returning <code>CMPI_RC_NEVER_UNLOAD</code>. This will cause the MB to consider this MI still to be initialized, and the MB may call further MI functions of this MI. The MB will not call this function again until the MB terminates (at which time the MB calls this function with terminating set to true). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes shall be used by the MI in the function return status: <ul>
<li><code>CMPI_RC_OK</code> - Function successful. </li>
<li><code>CMPI_RC_DO_NOT_UNLOAD</code> - Function successful, do not unload now; the MB may retry an unload later. </li>
<li><code>CMPI_RC_NEVER_UNLOAD</code> - Function successful, never unload; the MB will not retry an unload later unless it shuts down. </li>
<li><code>CMPI_RC_ERR_FAILED</code> - Other error occurred.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a> </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000011">Bug:</a></b></dt><dd>The <a class="el" href="index.html#ref-cmpi-standard">CMPI Standard</a> is not specific about the number of invocations of this function when an MI services more than one namespace. It should be updated to state that the function is invoked only once, even if the MI services more than one namespace. </dd></dl>

</div>
</div>
<a class="anchor" id="aac5520a37f447e153dddba1c4c12d32a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::enumerateInstanceNames)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate instance paths of instances of a given class serviced by this MI. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#aac5520a37f447e153dddba1c4c12d32a" title="Enumerate instance paths of instances of a given class serviced by this MI. ">CMPIInstanceMIFT.enumerateInstanceNames()</a> shall enumerate the instance paths of instances of a given class that are serviced by this MI, by accessing the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class of <code>classPath</code> for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in <code>classPath</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have put all instance paths representing the result set into this container. </td></tr>
    <tr><td class="paramname">classPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the given class and that contains the namespace and class name components. The hostname and key components, if present, have no meaning and should be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0201 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_FOUND</code></td><td>N/A </td><td>No instances found. (<b>Deprecated</b>) </td></tr>
<tr>
<td><code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code></td><td>WIPG0240 </td><td>Limits exceeded. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a></dd></dl>
<dl class="changed210"><dt><b><a class="el" href="changed210.html#_changed210000043">Change:</a></b></dt><dd>In CMPI 2.1, added the return code <code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>The return code <code>CMPI_RC_ERR_NOT_FOUND</code> of this function is deprecated since CMPI 2.1. Instead of using this return code if no instances are found, the MI should return success with an empty result data container. The MB shall treat this return code as a successful return of an empty result set. </dd></dl>

</div>
</div>
<a class="anchor" id="a32f65e050dd7a5a8b8a9d1446fbfcdcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::enumerateInstances)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const char **properties)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the instances of a given class that are serviced by this MI. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#a32f65e050dd7a5a8b8a9d1446fbfcdcd" title="Enumerate the instances of a given class that are serviced by this MI. ">CMPIInstanceMIFT.enumerateInstances()</a> shall enumerate the instances of a given class that are serviced by this MI, by accessing the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class of <code>classPath</code> for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in <code>classPath</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have put all instances representing the result set into this container. </td></tr>
    <tr><td class="paramname">classPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the given class and that contains the namespace and class name components. The hostname and key components, if present, have no meaning and should be ignored. </td></tr>
    <tr><td class="paramname">properties</td><td>If not NULL, is an array of zero or more pointers to strings, each specifying a property name. This set of property names will reflect the effects of any invocation flags specified in the <a class="el" href="group__def-context-fieldnames.html#gacee7849e119638639613f6408d8c1c19">CMPIInvocationFlags</a> entry of <code>ctx</code>. The end of the array is identified by a NULL pointer. Each returned object shall not include elements for any properties missing from this list. If the properties argument is NULL, this indicates that all properties shall be included in each returned object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0201 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_FOUND</code></td><td>N/A </td><td>No instances found. (<b>Deprecated</b>) </td></tr>
<tr>
<td><code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code></td><td>WIPG0240 </td><td>Limits exceeded. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a></dd></dl>
<dl class="changed210"><dt><b><a class="el" href="changed210.html#_changed210000044">Change:</a></b></dt><dd>In CMPI 2.1, added the return code <code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>The return code <code>CMPI_RC_ERR_NOT_FOUND</code> of this function is deprecated since CMPI 2.1. Instead of using this return code if no instances are found, the MI should return success with an empty result data container. The MB shall treat this return code as a successful return of an empty result set. </dd></dl>

</div>
</div>
<a class="anchor" id="acd99f019353734c2ef1eec95d4f605ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::getInstance)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *instPath, const char **properties)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an existing instance. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#acd99f019353734c2ef1eec95d4f605ba" title="Get an existing instance. ">CMPIInstanceMIFT.getInstance()</a> shall get an existing instance, by accessing the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class of the <code>instPath</code> argument for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in the <code>instPath</code> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have put the retrieved instance into this container. </td></tr>
    <tr><td class="paramname">instPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the instance to be retrieved and that contains the namespace, class name, and key components. The hostname component, if present, has no meaning and should be ignored. </td></tr>
    <tr><td class="paramname">properties</td><td>If not NULL, is an array of zero or more pointers to strings, each specifying a property name. The end of the array is identified by a NULL pointer. This set of property names will reflect the effects of any invocation flags specified in the <a class="el" href="group__def-context-fieldnames.html#gacee7849e119638639613f6408d8c1c19">CMPIInvocationFlags</a> entry of <code>ctx</code>. The returned instance shall not include elements for any properties missing from this list. If <code>properties</code> is NULL, this indicates that all properties shall be included in the returned instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by this MI </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0201 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_FOUND</code></td><td>WIPG0213 </td><td>Instance not found. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code></td><td>WIPG0240 </td><td>Limits exceeded. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a101d136d2ccc12fd098bf3499b2c96ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::createInstance)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const <a class="el" href="structCMPIInstance.html">CMPIInstance</a> *inst)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of a given class. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#a101d136d2ccc12fd098bf3499b2c96ca" title="Create an instance of a given class. ">CMPIInstanceMIFT.createInstance()</a> shall create an instance of a given class in the namespace of that class, by creating the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class of <code>classPath</code> for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in <code>classPath</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have put the instance path of the created instance into this container. </td></tr>
    <tr><td class="paramname">classPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the given class. The hostname and key components, if present, have no meaning and should be ignored. </td></tr>
    <tr><td class="paramname">inst</td><td>Points to a <a class="el" href="structCMPIInstance.html" title="CMPIInstance encapsulated data type object. ">CMPIInstance</a> object specifying property values for the new instance. The object path component within this <a class="el" href="structCMPIInstance.html" title="CMPIInstance encapsulated data type object. ">CMPIInstance</a> object has no meaning; it should not be provided by MBs and should not be used by MIs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0228 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_INVALID_PARAMETER</code></td><td>WIPG0249 </td><td>Invalid filter parameters. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ALREADY_EXISTS</code></td><td>WIPG0213 </td><td>Instance already exists. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code></td><td>WIPG0240 </td><td>Limits exceeded. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a></dd></dl>
<dl class="changed210"><dt><b><a class="el" href="changed210.html#_changed210000045">Change:</a></b></dt><dd>In CMPI 2.1, added the return code <code>CMPI_RC_ERR_ACCESS_DENIED</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>The use of the key component in <code>classPath</code> is deprecated since CMPI 2.1; the key component should not be provided by MBs and should not be used by MIs. </dd></dl>

</div>
</div>
<a class="anchor" id="a39091dc87dd2f06879afbb8ecc7da62b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::modifyInstance)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *instPath, const <a class="el" href="structCMPIInstance.html">CMPIInstance</a> *modInst, const char **properties)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify property values of an existing instance. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#a39091dc87dd2f06879afbb8ecc7da62b" title="Modify property values of an existing instance. ">CMPIInstanceMIFT.modifyInstance()</a> shall modify property values of an existing instance, by accessing the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class in <code>instPath</code> for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in <code>instPath</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have left this container empty. </td></tr>
    <tr><td class="paramname">instPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the instance to be modified and that contains the namespace, class name, and key components. The hostname component, if present, has no meaning and should be ignored. </td></tr>
    <tr><td class="paramname">modInst</td><td>Points to a CMIPInstance object specifying new values for the properties to be modified. The object path component within this <a class="el" href="structCMPIInstance.html" title="CMPIInstance encapsulated data type object. ">CMPIInstance</a> object has no meaning; it should not be provided by MBs and should not be used by MIs. </td></tr>
    <tr><td class="paramname">properties</td><td>If not NULL, is an array of zero or more pointers to strings, each specifying a property name. The end of the array is identified by a NULL pointer. The invocation flags specified in the <a class="el" href="group__def-context-fieldnames.html#gacee7849e119638639613f6408d8c1c19">CMPIInvocationFlags</a> entry of <code>ctx</code> have no meaning for this function. The function shall not modify elements for any properties missing from this list. If <code>properties</code> is NULL, this indicates that all properties specified in <code>modInst</code> are modified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0228 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_INVALID_PARAMETER</code></td><td>WIPG0249 </td><td>Invalid filter parameters. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_FOUND</code></td><td>WIPG0213 </td><td>Instance not found. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NO_SUCH_PROPERTY</code></td><td>WIPG0220 </td><td>No such property. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a></dd></dl>
<dl class="changed210"><dt><b><a class="el" href="changed210.html#_changed210000046">Change:</a></b></dt><dd>In CMPI 2.1, added the return code <code>CMPI_RC_ERR_NO_SUCH_PROPERTY</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad186fef3dd991a1e9b2551102b0ac1c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::deleteInstance)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *op)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing instance. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#ad186fef3dd991a1e9b2551102b0ac1c3" title="Delete an existing instance. ">CMPIInstanceMIFT.deleteInstance()</a> shall delete an existing instance, by deleting the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class in <code>instPath</code> for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in <code>instPath</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have left this container empty. </td></tr>
    <tr><td class="paramname">instPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the instance to be deleted and that contains the namespace, class name, and key components. The hostname component, if present, has no meaning and should be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0228 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_FOUND</code></td><td>WIPG0213 </td><td>Instance not found. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa391cf28e2369eeea1776b55201a2da2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::execQuery)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const char *query, const char *lang)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a query on a given class and return the query result. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#aa391cf28e2369eeea1776b55201a2da2" title="Execute a query on a given class and return the query result. ">CMPIInstanceMIFT.execQuery()</a> shall execute a query on a given class and return the query result, by accessing the underlying managed elements.</p>
<p>This function is provided by the MI in context of a particular MI name. The class in <code>classPath</code> for which this function will be called by the MB depends on the specifics of how the MB relates classes and MI names, which is out of scope for this standard. As a result, the MB may call this function for classes for which the MI is not responsible. In order for an MI to be portable across MB implementations with different approaches to relate MI names and classes, the MI must check whether it services the class specified in <code>classPath</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return, the MI shall have left this container empty. </td></tr>
    <tr><td class="paramname">classPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the given class and that contains the namespace and class name components. The hostname and key components, if present, have no meaning and should be ignored. </td></tr>
    <tr><td class="paramname">query</td><td>Select expression. </td></tr>
    <tr><td class="paramname">lang</td><td>Query language (case-sensitive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0201 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_QUERY_LANGUAGE_NOT_SUPPORTED</code> </td><td>WIPG0221 </td><td>Query language not supported. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_QUERY_FEATURE_NOT_SUPPORTED</code> </td><td>WIPG0222 </td><td>A feature of the query language is not supported. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_INVALID_QUERY</code> </td><td>WIPG02223 </td><td>Invalid Query. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_FOUND</code></td><td>WIPG0213 </td><td>Instance not found. (<b>Deprecated</b>) </td></tr>
<tr>
<td><code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code></td><td>WIPG0240 </td><td>Limits exceeded. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a></dd></dl>
<dl class="changed210"><dt><b><a class="el" href="changed210.html#_changed210000047">Change:</a></b></dt><dd>In CMPI 2.1, added the return codes <code>CMPI_RC_ERR_QUERY_FEATURE_NOT_SUPPORTED</code> and <code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>The return code <code>CMPI_RC_ERR_NOT_FOUND</code> of this function is deprecated since CMPI 2.1. Instead of using this return code if no instances are found, the MI should return success with an empty result data container. The MB shall treat this return code as a successful return of an empty result set. </dd></dl>

</div>
</div>
<a class="anchor" id="a3407e6bd5c82e70bbd02a00260b8d69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCMPIStatus.html">CMPIStatus</a>(* CMPIInstanceMIFT::enumerateInstancesFiltered)(<a class="el" href="structCMPIInstanceMI.html">CMPIInstanceMI</a> *mi, const <a class="el" href="structCMPIContext.html">CMPIContext</a> *ctx, const <a class="el" href="structCMPIResult.html">CMPIResult</a> *rslt, const <a class="el" href="structCMPIObjectPath.html">CMPIObjectPath</a> *classPath, const char **properties, const char *filterQuerylanguage, const char *filterQuery, <a class="el" href="structCMPIStatus.html">CMPIStatus</a> *rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the instances of a given class that are serviced by this MI, returning only those that match a given query filter. </p>
<p><a class="el" href="structCMPIInstanceMIFT.html#a3407e6bd5c82e70bbd02a00260b8d69a" title="Enumerate the instances of a given class that are serviced by this MI, returning only those that matc...">CMPIInstanceMIFT.enumerateInstancesFiltered()</a> shall enumerate the instances of a given class that are serviced by this MI, returning only those instances that match a given query filter, by enumerating the underlying managed elements. The returned instances shall have their instance paths set. If no such instances are found, the function shall return success with an empty result data container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>Points to a <a class="el" href="structCMPIInstanceMI.html" title="CMPIInstanceMI object. ">CMPIInstanceMI</a> structure. </td></tr>
    <tr><td class="paramname">ctx</td><td>Points to a <a class="el" href="structCMPIContext.html" title="CMPIContext encapsulated data type object. ">CMPIContext</a> object containing the context data for the invocation. </td></tr>
    <tr><td class="paramname">rslt</td><td>Points to a <a class="el" href="structCMPIResult.html" title="CMPIResult encapsulated data type object. ">CMPIResult</a> object that is the result data container. Upon successful return the MI shall have put all instances representing the result set into this container. </td></tr>
    <tr><td class="paramname">classPath</td><td>Points to a <a class="el" href="structCMPIObjectPath.html" title="CMPIObjectPath encapsulated data type object. ">CMPIObjectPath</a> object that references the given class and that contains namespace and class name components. The hostname and key components, if present, have no meaning and should be ignored. </td></tr>
    <tr><td class="paramname">properties</td><td>If not NULL, is an array of zero or more pointers to strings, each specifying a property name. The end of the array is identified by a NULL pointer. This set of property names will reflect the effects of any invocation flags specified in the <a class="el" href="group__def-context-fieldnames.html#gacee7849e119638639613f6408d8c1c19">CMPIInvocationFlags</a> entry of <code>ctx</code>. Each returned instance shall not include elements for any properties missing from this list. If <code>properties</code> is NULL, this indicates that all properties shall be included in each returned instance. </td></tr>
    <tr><td class="paramname">filterQueryLanguage</td><td>Query language used by <code>filterQuery</code>. If NULL, no filtering is performed. Note that FQL (see <a class="el" href="index.html#ref-dmtf-dsp0212">DSP0212</a>) is required to be supported by MIs as a query language; see Subclause 4.5 in the <a class="el" href="index.html#ref-cmpi-standard">CMPI Standard</a>. </td></tr>
    <tr><td class="paramname">filterQuery</td><td>Query in the query language defined by <code>filterQueryLanguage</code>. If NULL, no filtering is performed. A request that specifies a filter through valid and non-NULL <code>filterQueryLanguage</code> and <code>filterQuery</code> arguments shall return only instances that match that filter as defined in the filter specification. </td></tr>
    <tr><td class="paramname">continueOnError</td><td>Defines whether this operation may continue to return objects after it returns an error. If false, the MI shall terminate after returning an error to the result data container. If true, the MI may continue to return data (objects and subsequent errors) to the result data container after returning an error. An MI that cannot continue after returning an error shall ignore the value of <code>continueOnError</code> and shall behave as if it was specified as false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structCMPIStatus.html" title="A structure that indicates success or failure of MB and MI functions. ">CMPIStatus</a> structure containing the function return status.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The following table lists the <a class="el" href="group__type-rc.html#ga20a37bfb081e01ed1fc1b64f571cfd42">CMPIrc</a> codes that shall be used by the MI in the function return status, as well as the WBEM operation messages that should be used in the <a class="el" href="structCMPIError.html" title="CMPIError encapsulated data type object. ">CMPIError</a> object if the MI supports extended error handling (see the corresponding <a class="el" href="caperrors.html#cap-errors">Extended Errors</a> capability): <table class="doxtable">
<tr>
<th>CMPIRCCode</th><th>CMPIErrorMsg</th><th>Description </th></tr>
<tr>
<td><code>CMPI_RC_OK</code></td><td>N/A </td><td>Function Successful. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_NOT_SUPPORTED</code></td><td>WIPG0228 </td><td>Function is not supported by the MB. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_ACCESS_DENIED</code></td><td>WIPG0201 </td><td>Not authorized. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_SERVER_LIMITS_EXCEEDED</code></td><td>WIPG0240 </td><td>Limits exceeded. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_QUERY_LANGUAGE_NOT_SUPPORTED</code> </td><td>WIPG0221</td><td>Query language not supported. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_QUERY_FEATURE_NOT_SUPPORTED</code> </td><td>WIPG0222 </td><td>A feature of the query language is not supported. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_INVALID_QUERY</code> </td><td>WIPG0223</td><td>Invalid query. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0243 </td><td>Timeout occurred. </td></tr>
<tr>
<td><code>CMPI_RC_ERR_FAILED</code></td><td>WIPG0227 + implementation-specific message </td><td>Other error occurred. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Convenience Function</dt><dd><a class="el" href="group__convenience-func-mi-factory-stubs.html#gafa21d4cd10d364743d7c0135303171ba" title="Generate function table and factory function for an instance MI written in plain C. ">CMInstanceMIStub()</a></dd></dl>
<dl class="added210"><dt><b><a class="el" href="added210.html#_added210000030">Addition:</a></b></dt><dd>Added in CMPI 2.1. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="cmpift_8h_source.html">cmpift.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 3 2015 18:17:03 for CMPI Standard by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
